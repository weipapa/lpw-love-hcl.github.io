{"meta":{"title":"Wei's blog","subtitle":"","description":"","author":"weipapa","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-06-18T11:13:45.668Z","updated":"2020-06-18T11:13:45.668Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-06-18T11:23:45.919Z","updated":"2020-06-18T11:23:45.919Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"新时代的土豆削皮工，第一届清水河畔花样切土豆比赛冠军"},{"title":"所有标签","date":"2020-06-18T11:14:00.277Z","updated":"2020-06-18T11:14:00.277Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-06-19T01:42:57.305Z","updated":"2020-06-19T01:42:57.305Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""},{"title":"","date":"2020-06-18T11:31:23.856Z","updated":"2020-06-18T11:31:23.856Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"12345678910layout: pagetitle: 404 Not Foundbody: [article, comments]meta: header: [] footer: []sidebar: []valine: path: &#x2F;404.html placeholder: 请留言告诉我您要访问哪个页面找不到了 404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"}],"posts":[{"title":"TCP三次握手与四次挥手","slug":"TCP三次握手与四次挥手","date":"2020-07-03T03:26:48.000Z","updated":"2020-07-03T03:32:31.113Z","comments":true,"path":"2020/07/03/TCP三次握手与四次挥手/","link":"","permalink":"http://yoursite.com/2020/07/03/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","excerpt":"1. 计算机网络模型体系结构计算机网络模型体系结构如图，TCP 属于运输层 (传输层) 的协议，传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。","text":"1. 计算机网络模型体系结构计算机网络模型体系结构如图，TCP 属于运输层 (传输层) 的协议，传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。 2. TCP 首部 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 3. TCP 三次握手 B 的 TCP 服务器进程先创建传输控制块 TCB，服务器进程就处于 LISTEN (收听) 状态，准备接受客户进程的连接请求。 A 的 TCP 服务器也是先创建传输控制块 TCB，然后向B发出连接请求报文段，这时首部中的同步位 SYN=1，同时选择一个初始序号 seq=x。TCP 规定，SYN=1 的报文段不能携带数据，但消耗掉一个序号。这时 TCP 客户端进程进入 SYN-SENT (同步已发送) 状态。 B 收到连接请求报文段后，如同意建立连接，则向A发送确认。在确认报文段中应把 SYN 位和 ACK 位都置1。确认号是 ack=x+1。同时也为自己选择个初始序号 seq=y。请注意，这个报文段也不能携带数据，但同样要消耗掉个一序号。 这时TCP服务器进程进入 SYN-RCVD (同步收到) 状志。 TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置1。确认号 ack=y+1，而自己的序号 seq=x+1。 TCP 的标准规定，ACK报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是 seq=x+1。这时，TCP连接已经建立，A 进入 ESTABLISHED (已建立连接)状志。 当B收到A的确认后，也进入 ESTABLISHED状态。 三次握手的原因： 为什么 A 还要发送次确认呢？这主要是为了防止 “已失效的请求报文段” 突然又传送到了 B，因而产生错误。 考虑一种正常情况，A 发出连接请求，但因连接请求报文丢失而未收到确认，于是 A 再重传一次连接请求。后来收到了确认，建立连接。A 一共发送了两个连接请求报文段，其中第一个丢失，第二个到达了B，没有 “已失效的连接请求报文段”。 现假定一种异常情况，即 A 发出的第一个连接请求报文段没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放后的某个时间才到达B。本来这事一个早已失效的报文段，但是 B 收到此失效的报文段后，就误认为是 A 又发出了依次新的连接请求。于是向 A 发出确认报文段，同意建立连接。假定不采用三次握手，那么只要 B 发出确认，新的连接就建立了。可是 A 并没有建立连接的请求，因此不会理财 B 的确认，也不会向 B 发送数据，但 B 确认为新的连接建立了，一直等待 A 发数据。B 的很多资源就这样白白浪费了。 采用三次握手可以防止上述现象的发生。例如在刚才的情况下，A 不会向 B 的确认发出确认。B 由于收不到确认，就知道 A 并没有要求建立连接。 4. TCP 四次挥手 A 发送连接释放报文，FIN=1，seq=u，它等于前面已经传送过的数据的最后一个字节的序号加1。这时 A 进入 FIN-WAIT-1 (终止等待 1) 状态，等待 B 的确认。 B 收到之后发出确认，确认号 ack=u+1，然后B进入 CLOSED-WAIT (关闭等待) 状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。发送连接释放报文，FIN=1，seq=w (在半关闭状态可能又法了一些数据)，重复确认后 ack=u+1，B 进入 LAST-ACK (最后确认) 状态。 A 收到 B 的确认后发出确认，ack=w+1，seq=u+1，然后进入 TIME-WAIT (时间等待) 状态，等待 2 MSL（最大报文存活时间）后释放连接。 B 收到 A 的确认后释放连接。 四次挥手的原因 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 TIME_WAIT 状态必须等待 2MSL 的原因： 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由： 确保 A 发送的最后一个 ACK 报文段能够到达 B 。这个 ACK 报文段有可能丢失，因而使处在LAST-ACK状态的B 收不到 ACK 报文段，那么这时 B 会重发 FIN+ACK报文段，而 A 就能在 2MSL的时间内收到然后再重发 如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。 防止 “已失效的请求报文段” 突然出现再连接中，等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://yoursite.com/tags/TCP-IP/"}]},{"title":"Hexo常用命令","slug":"Hexo常用命令","date":"2020-07-03T03:22:55.000Z","updated":"2020-07-03T03:24:39.607Z","comments":true,"path":"2020/07/03/Hexo常用命令/","link":"","permalink":"http://yoursite.com/2020/07/03/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"使用hexo写博客上传到GitHub的一些命令常用命令 1234567hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本","text":"使用hexo写博客上传到GitHub的一些命令常用命令 1234567hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写： 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令： 12hexo s -g #生成并本地预览hexo d -g #生成并上传 博客格式： 使用hexo new命令产生的 md 文件需要做如下改动，再上传。 123456789---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文","categories":[{"name":"备忘","slug":"备忘","permalink":"http://yoursite.com/categories/%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Java内存区域","slug":"Java内存区域","date":"2020-07-03T03:12:38.000Z","updated":"2020-07-03T03:33:10.398Z","comments":true,"path":"2020/07/03/Java内存区域/","link":"","permalink":"http://yoursite.com/2020/07/03/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/","excerpt":"1. Java内存区域详解Java虚拟机主要有一下几部分组成","text":"1. Java内存区域详解Java虚拟机主要有一下几部分组成 下面以一张图详细解释每部分的组成 1.1 程序计数器程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。 另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 从上面的介绍中我们知道程序计数器主要有两个作用： 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。 1.2 Java虚拟机栈与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。 Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack), 其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。 （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。） 局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。 Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。 StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。 OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。 Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。 扩展：那么方法/函数如何调用？ Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。 Java 方法有两种返回方式： return 语句。 抛出异常。 不管哪种返回方式都会导致栈帧被弹出。 1.3 本地方法栈和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。 1.4 堆Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。 Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）。从垃圾回收的角度，由于现在收集器大部分都采用分代垃圾收集算法，所以 Java 堆中经常会出现”新生代“、”老年代“、”Eden 空间“、”From Survivor空间“、”To Survivor 空间”等名词，这只是垃圾回收器的一种设计风格，并不是某个Java虚拟机的固有内存布局。进一步划分的目的是更好地回收内存，或者更快地分配内存。 Java堆可以处于物理上不连续的内存空间中，但在逻辑上应该被视为是连续的，这点就像我们用磁盘空间去存储文件一样。 Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的。如果Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。 1.5 方法区方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。 如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。 1.6 运行时常量池 JDK1.7之前的运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。 JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。 1.7 直接内存直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。 JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。 本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。 2. HotSpot虚拟机对象探秘2.1 对象的创建 Java对象的创建过程 Step1:类加载检查虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 Step2:分配内存在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 内存分配的两种方式： 指针碰撞： 适用场合：堆内存规整，即没有内存碎片的情况下； 原理：用过的内存全部被放到一边，空闲的内存放到另一边，中间放着一个指针作为分界点的指示器，那所分配的内存就仅仅时把那个指针向空闲方向移动一段与内存大小相等的距离； GC：Serial、ParNew。 空闲列表： 适用场合：堆内存不规整的情况下； 原理：虚拟机维护一个列表，记录哪些内存块时可以使用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录； GC：CMS 内存分配并发问题在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种可选方案： CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。 TLAB： 把内存分配的动作按照线程划分在不同的空间进行，即每个线程在Java堆中预先分配一小块内存，为每一个线程预先在 Eden 区分配一块儿内存，称为本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)，哪个线程要分配内存，就在哪个线程的本地缓冲区分配，只有本地缓冲区用完了，分配新的缓冲区时才需要同步锁定。 Step3:初始化零值内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 Step4:设置对象头初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 Step5:执行 init 方法在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，&lt;init&gt;() 方法还没有执行，所有的字段都是默认的零值，对象需要的其他资源和状态信息还没有按照预定意图构造好。所以一般来说，执行 new 指令之后会接着执行 &lt;init&gt;() 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 2.2 对象的内存布局在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。 Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码(HashCode)、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。 实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。 对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 2.3 对象的访问定位建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有①使用句柄和②直接指针两种： 句柄： 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。 直接指针： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。 3. 重点补充内容3.1 String 类和常量池String 对象的两种创建方式： 12345String str1 &#x3D; &quot;abcd&quot;;&#x2F;&#x2F;先检查字符串常量池中有没有&quot;abcd&quot;，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向&quot;abcd&quot;&quot;；String str2 &#x3D; new String(&quot;abcd&quot;);&#x2F;&#x2F;堆中创建一个新的对象String str3 &#x3D; new String(&quot;abcd&quot;);&#x2F;&#x2F;堆中创建一个新的对象System.out.println(str1&#x3D;&#x3D;str2);&#x2F;&#x2F;falseSystem.out.println(str2&#x3D;&#x3D;str3);&#x2F;&#x2F;false 这两种不同的创建方法是有差别的。 第一种方式是在常量池中拿对象； 第二种方式是直接在堆内存空间创建一个新的对象。 记住一点：只要使用 new 方法，便需要创建新的对象。 再给大家一个图应该更容易理解，图片来源：https://www.journaldev.com/797/what-is-java-string-pool： String 类型的常量池比较特殊。它的主要使用方法有两种： 直接使用双引号声明出来的 String 对象会直接存储在常量池中。 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。 123456String s1 = new String(\"计算机\");String s2 = s1.intern();String s3 = \"计算机\";System.out.println(s2);//计算机System.out.println(s1 == s2);//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，System.out.println(s3 == s2);//true，因为两个都是常量池中的 String 对象 字符串拼接: 123456789String str1 = \"str\";String str2 = \"ing\";String str3 = \"str\" + \"ing\";//常量池中的对象String str4 = str1 + str2; //在堆上创建的新的对象 String str5 = \"string\";//常量池中的对象System.out.println(str3 == str4);//falseSystem.out.println(str3 == str5);//trueSystem.out.println(str4 == str5);//false 尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。 3.2 String s1 = new String(“abc”);这句话创建了几个字符串对象？将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。 验证： 1234String s1 = new String(\"abc\");// 堆内存的地址值String s2 = \"abc\";System.out.println(s1 == s2);// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。System.out.println(s1.equals(s2));// 输出 true 3.3 8 种基本类型的包装类和常量池Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。 为啥把缓存设置为[-128，127]区间？（参见issue/461）性能和资源之间的权衡。 12345678910111213public static Boolean valueOf(boolean b) &#123; return (b ? TRUE : FALSE);&#125;private static class CharacterCache &#123; private CharacterCache()&#123;&#125; static final Character cache[] = new Character[127 + 1]; static &#123; for (int i = 0; i &lt; cache.length; i++) cache[i] = new Character((char)i); &#125; &#125; 两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。 123456789Integer i1 = 33;Integer i2 = 33;System.out.println(i1 == i2);// 输出 trueInteger i11 = 333;Integer i22 = 333;System.out.println(i11 == i22);// 输出 falseDouble i3 = 1.2;Double i4 = 1.2;System.out.println(i3 == i4);// 输出 false Integer 缓存源代码： 12345678/***此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。*/public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 应用场景： Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40)，从而使用常量池中的对象。 Integer i1 = new Integer(40);这种情况下会创建新的对象。 123Integer i1 = 40;Integer i2 = new Integer(40);System.out.println(i1==i2);//输出 false Integer 比较更丰富的一个例子: 12345678910111213Integer i1 = 40;Integer i2 = 40;Integer i3 = 0;Integer i4 = new Integer(40);Integer i5 = new Integer(40);Integer i6 = new Integer(0);System.out.println(\"i1==i2 \" + (i1 == i2));System.out.println(\"i1==i2+i3 \" + (i1 == i2 + i3));System.out.println(\"i1==i4 \" + (i1 == i4));System.out.println(\"i4==i5 \" + (i4 == i5));System.out.println(\"i4==i5+i6 \" + (i4 == i5 + i6)); System.out.println(\"40==i5+i6 \" + (40 == i5 + i6)); 结果： 123456i1=i2 truei1=i2+i3 truei1=i4 falsei4=i5 falsei4=i5+i6 true40=i5+i6 true 解释： 语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"科学上网","slug":"科学上网","date":"2020-06-19T01:46:15.000Z","updated":"2020-06-19T01:46:50.415Z","comments":true,"path":"2020/06/19/科学上网/","link":"","permalink":"http://yoursite.com/2020/06/19/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/","excerpt":"SSR服务器端一键安装命令wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh","text":"SSR服务器端一键安装命令wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh SSR管理命令1bash ssrmu.sh 访问谷歌学术方法123456vi &#x2F;etc&#x2F;hosts##先在网页开启ipv6,编辑&#x2F;etc&#x2F;hosts,文件末尾加上2404:6800:4008:c06::be scholar.google.com2404:6800:4008:c06::be scholar.google.com.hk2404:6800:4008:c06::be scholar.google.com.tw2404:6800:4005:805::200e scholar.google.cn #www.google.cn SS服务器端一键安装wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh chmod +x shadowsocks.sh ./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log SS服务器相关命令启动：/etc/init.d/shadowsocks start 停止：/etc/init.d/shadowsocks stop 重启：/etc/init.d/shadowsocks restart 状态：/etc/init.d/shadowsocks status 配置文件路径：/etc/shadowsocks.json 日志文件路径：/var/log/shadowsocks.log 安装路径：/usr/local/shadowsocks/shadowsoks SSR服务器端相关命令启动：/etc/init.d/ssr start 停止：/etc/init.d/ssr stop 重启：/etc/init.d/ssr restart 状态：/etc/init.d/ssr status 配置文件路径：/etc/shadowsocksr/user-config.json 日志文件路径：/var/log/shadowsocks.log 安装路径：/usr/local/shadowsocks/shadowsoks","categories":[{"name":"备忘","slug":"备忘","permalink":"http://yoursite.com/categories/%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"科学上网","slug":"科学上网","permalink":"http://yoursite.com/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"}]},{"title":"GitHub配置ssh-key","slug":"GitHub配置ssh-key","date":"2020-06-19T01:14:17.000Z","updated":"2020-06-19T01:17:38.597Z","comments":true,"path":"2020/06/19/GitHub配置ssh-key/","link":"","permalink":"http://yoursite.com/2020/06/19/GitHub%E9%85%8D%E7%BD%AEssh-key/","excerpt":"有了GitHub账号之后，我们有时候需要从GitHub上clone项目，或者将自己本地的项目push到GitHub上，这事就需要我们先在本地生成一个ssh-key，在GitHub上添加这个key。","text":"有了GitHub账号之后，我们有时候需要从GitHub上clone项目，或者将自己本地的项目push到GitHub上，这事就需要我们先在本地生成一个ssh-key，在GitHub上添加这个key。 注意：本文中所有命令行{}所框内容表示需要自行修改。 一、设置git的name和email这里的name和email分别是GitHub的name和email 12git config --global user.name \"&#123;username&#125;\"git config --global user.email \"&#123;email@163.com&#125;\" 查看当前git环境所有配置 1git config --list 二、生成SSH-KEY1. 先检查是否存在SSH-KEY1ll ~/.ssh 如果有id_rsa和id_rsa.pub文件，表示已经存在SSH-KEY 2.如果不存在则生成SSH-KEY1ssh-keygen -t rsa -C \"&#123;email@163.com&#125;\" 三、获取SSH-KEY1cat id_rsa.pub 复制秘钥 四、GitHub添加SSH-KEY1. 点击Settings 2. 点击SSH and GPG keys 3. 新建SSH keys 取个名字，将复制的秘钥粘贴进去即可 五、验证1ssh -T git@github.com 运行出现Hi ***! You&#39;ve successfully authenticated, but GitHub does not provide shell access.则表示成功。","categories":[{"name":"备忘","slug":"备忘","permalink":"http://yoursite.com/categories/%E5%A4%87%E5%BF%98/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"Spring笔记","slug":"Spring笔记","date":"2020-06-18T10:23:25.000Z","updated":"2020-06-18T12:25:02.765Z","comments":true,"path":"2020/06/18/Spring笔记/","link":"","permalink":"http://yoursite.com/2020/06/18/Spring%E7%AC%94%E8%AE%B0/","excerpt":"1.Spring概述","text":"1.Spring概述 1. 简介Spring : 春天 —&gt;给软件行业带来了春天 2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。 2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。 很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。 Spring理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术 官网 : http://spring.io/ 官方下载地址 : https://repo.spring.io/libs-release-local/org/springframework/spring/ GitHub : https://github.com/spring-projects 123456789101112&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 2.优点1、Spring是一个开源免费的框架 , 容器 . 2、Spring是一个轻量级的框架 , 非侵入式的 . 3、控制反转 IoC , 面向切面 Aop 4、对事物的支持 , 对框架的支持 ……. 一句话概括： ==Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。== 3.组成 Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 . 组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下： 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。 Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 4.拓展Spring Boot与Spring Cloud Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务; Spring Cloud是基于Spring Boot实现的； Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架； Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。 SpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习SpringBoot。 2.IoC基础新建一个空白的maven项目 1.分析实现我们先用我们原来的方式写一段代码 . 1、先写一个UserDao接口 123public interface UserDao &#123; public void getUser();&#125; 2、再去写Dao的实现类 123456public class UserDaoImpl implements UserDao &#123; @Override public void getUser() &#123; System.out.println(\"获取用户数据\"); &#125;&#125; 3、然后去写UserService的接口 123public interface UserService &#123; public void getUser();&#125; 4、最后写Service的实现类 12345678public class UserServiceImpl implements UserService &#123; private UserDao userDao = new UserDaoImpl(); @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; 5、测试一下 12345@Testpublic void test()&#123; UserService service = new UserServiceImpl(); service.getUser();&#125; 这是我们原来的方式 , 开始大家也都是这么去写的对吧 . 那我们现在修改一下 . 把Userdao的实现类增加一个 . 123456public class UserDaoMySqlImpl implements UserDao &#123; @Override public void getUser() &#123; System.out.println(\"MySql获取用户数据\"); &#125;&#125; 紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现 12345678public class UserServiceImpl implements UserService &#123; private UserDao userDao = new UserDaoMySqlImpl(); @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; 在假设, 我们再增加一个Userdao的实现类 . 123456public class UserDaoOracleImpl implements UserDao &#123; @Override public void getUser() &#123; System.out.println(\"Oracle获取用户数据\"); &#125;&#125; 那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现 . 假设我们的这种需求非常大 , 这种方式就根本不适用了, 甚至反人类对吧 , 每次变动 , 都需要修改大量代码 . 这种设计的耦合性太高了, 牵一发而动全身 . 那我们如何去解决呢 ? 我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set , 我们去代码里修改下 . 123456789101112public class UserServiceImpl implements UserService &#123; private UserDao userDao;// 利用set实现 public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; 现在去我们的测试类里 , 进行测试 ; 123456789@Testpublic void test()&#123; UserServiceImpl service = new UserServiceImpl(); service.setUserDao( new UserDaoMySqlImpl() ); service.getUser(); //那我们现在又想用Oracle去实现呢 service.setUserDao( new UserDaoOracleImpl() ); service.getUser();&#125; 大家发现了区别没有 ? 可能很多人说没啥区别 . 但是同学们 , 他们已经发生了根本性的变化 , 很多地方都不一样了 . 仔细去思考一下 , 以前所有东西都是由程序去进行控制创建 , 而现在是由我们自行控制创建对象 , 把主动权交给了调用者 . 程序不用去管怎么创建,怎么实现了 . 它只负责提供一个接口 . 这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 ! 2.IOC本质控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。 IoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。 Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。 3.HelloSpring1. 导入Jar包注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 . 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt;&lt;/dependency&gt; 2. 编写代码1、编写一个Hello实体类 1234567891011121314public class Hello &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(\"Hello,\"+ name ); &#125;&#125; 2、编写我们的spring文件 , 这里我们命名为beans.xml 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--bean就是java对象 , 由Spring创建和管理--&gt; &lt;bean id=\"hello\" class=\"com.kuang.pojo.Hello\"&gt; &lt;property name=\"name\" value=\"Spring\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 3、我们可以去进行测试了 . 12345678@Testpublic void test()&#123; //解析beans.xml文件 , 生成管理相应的Bean对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); //getBean : 参数即为spring配置文件中bean的id . Hello hello = (Hello) context.getBean(\"hello\"); hello.show();&#125; 3. 思考 Hello 对象是谁创建的 ? 【hello 对象是由Spring创建的 Hello 对象的属性是怎么设置的 ? hello 对象的属性是由Spring容器设置的 这个过程就叫控制反转 : 控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 反转 : 程序本身不创建对象 , 而变成被动的接收对象 . 依赖注入 : 就是利用set方法来进行注入的. IOC是一种编程思想，由主动的编程变成被动的接收 可以通过newClassPathXmlApplicationContext去浏览一下底层源码 . 修改案例一 我们在案例一中， 新增一个Spring配置文件beans.xml 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"MysqlImpl\" class=\"com.kuang.dao.impl.UserDaoMySqlImpl\"/&gt; &lt;bean id=\"OracleImpl\" class=\"com.kuang.dao.impl.UserDaoOracleImpl\"/&gt; &lt;bean id=\"ServiceImpl\" class=\"com.kuang.service.impl.UserServiceImpl\"&gt; &lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt; &lt;!--引用另外一个bean , 不是用value 而是用 ref--&gt; &lt;property name=\"userDao\" ref=\"OracleImpl\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试！ 123456@Testpublic void test2()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); UserServiceImpl serviceImpl = (UserServiceImpl) context.getBean(\"ServiceImpl\"); serviceImpl.getUser();&#125; OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 ! 4.IOC创建对象方式 通过无参构造方法来创建 1、User.java 1234567891011121314151617public class User &#123; private String name; public User() &#123; System.out.println(\"user无参构造方法\"); &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(\"name=\"+ name ); &#125;&#125; 2、beans.xml 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"user\" class=\"com.kuang.pojo.User\"&gt; &lt;property name=\"name\" value=\"kuangshen\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 3、测试类 12345678@Testpublic void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); //在执行getBean的时候, user已经创建好了 , 通过无参构造 User user = (User) context.getBean(\"user\"); //调用对象的方法 . user.show();&#125; 加载配置文件ClassPathXmlApplicationContext(“beans.xml”)时，User对象已经通过无参构造初始化了！ 通过有参构造方法来创建 1、UserT . java 1234567891011121314151617public class UserT &#123; private String name; public UserT(String name) &#123; this.name = name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(\"name=\"+ name ); &#125;&#125; 2、beans.xml 有三种方式编写 1234567891011121314&lt;!-- 第一种根据index参数下标设置 --&gt;&lt;bean id=\"userT\" class=\"com.kuang.pojo.UserT\"&gt; &lt;!-- index指有参构造器中的参数位置, 下标从0开始 --&gt; &lt;constructor-arg index=\"0\" value=\"kuangshen2\"/&gt;&lt;/bean&gt;&lt;!-- 第二种根据参数名字设置 --&gt;&lt;bean id=\"userT\" class=\"com.kuang.pojo.UserT\"&gt; &lt;!-- name指参数名 --&gt; &lt;constructor-arg name=\"name\" value=\"kuangshen2\"/&gt;&lt;/bean&gt;&lt;!-- 第三种根据参数类型设置 --&gt;&lt;bean id=\"userT\" class=\"com.kuang.pojo.UserT\"&gt; &lt;constructor-arg type=\"java.lang.String\" value=\"kuangshen2\"/&gt;&lt;/bean&gt; 3、测试 123456@Testpublic void testT()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); UserT user = (UserT) context.getBean(\"userT\"); user.show();&#125; 结论：在配置文件加载的时候。其中管理的对象都已经初始化了！ 5.Spring配置1. 别名alias 设置别名 , 为bean设置别名 , 可以设置多个别名 12&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;&lt;alias name=\"userT\" alias=\"userNew\"/&gt; 2. Bean的配置12345678910111213&lt;!--bean就是java对象,由Spring创建和管理--&gt;&lt;!-- id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符 如果配置id,又配置了name,那么name是别名 name可以设置多个别名,可以用逗号,分号,空格隔开 如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;class是bean的全限定名=包名+类名--&gt;&lt;bean id=\"hello\" name=\"hello2 h2,h3;h4\" class=\"com.kuang.pojo.Hello\"&gt; &lt;property name=\"name\" value=\"Spring\"/&gt;&lt;/bean&gt; 3. import团队的合作通过import来实现 . 1&lt;import resource&#x3D;&quot;&#123;path&#125;&#x2F;beans.xml&quot;&#x2F;&gt; 6.依赖注入（DI）Dependency Injection 1. 概念 依赖注入（Dependency Injection,DI）。 依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 . 注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 . 2. 构造器注入我们在之前的案例已经讲过了 3. Set方式注入 （重点）要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is . 测试pojo类 : Address.java 123456789101112public class Address &#123; private String address; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; Student.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.kuang.pojo;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class Student &#123; private String name; private Address address; private String[] books; private List&lt;String&gt; hobbys; private Map&lt;String,String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info; public void setName(String name) &#123; this.name = name; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public void setBooks(String[] books) &#123; this.books = books; &#125; public void setHobbys(List&lt;String&gt; hobbys) &#123; this.hobbys = hobbys; &#125; public void setCard(Map&lt;String, String&gt; card) &#123; this.card = card; &#125; public void setGames(Set&lt;String&gt; games) &#123; this.games = games; &#125; public void setWife(String wife) &#123; this.wife = wife; &#125; public void setInfo(Properties info) &#123; this.info = info; &#125; public void show()&#123; System.out.println(\"name=\"+ name + \",address=\"+ address.getAddress() + \",books=\" ); for (String book:books)&#123; System.out.print(\"&lt;&lt;\"+book+\"&gt;&gt;\\t\"); &#125; System.out.println(\"\\n爱好:\"+hobbys); System.out.println(\"card:\"+card); System.out.println(\"games:\"+games); System.out.println(\"wife:\"+wife); System.out.println(\"info:\"+info); &#125;&#125; 4. 拓展方式注入1、常量注入 123&lt;bean id=\"student\" class=\"com.kuang.pojo.Student\"&gt; &lt;property name=\"name\" value=\"小明\"/&gt;&lt;/bean&gt; 测试： 123456789@Testpublic void test01()&#123; ApplicationContext context = newClassPathXmlApplicationContext(\"applicationContext.xml\"); Student student = (Student) context.getBean(\"student\"); System.out.println(student.getName());&#125; 2、Bean注入 注意点：这里的值是一个引用，ref 12345678&lt;bean id=\"addr\" class=\"com.kuang.pojo.Address\"&gt; &lt;property name=\"address\" value=\"重庆\"/&gt;&lt;/bean&gt;&lt;bean id=\"student\" class=\"com.kuang.pojo.Student\"&gt; &lt;property name=\"name\" value=\"小明\"/&gt; &lt;property name=\"address\" ref=\"addr\"/&gt;&lt;/bean&gt; 3、数组注入 1234567891011&lt;bean id=\"student\" class=\"com.kuang.pojo.Student\"&gt; &lt;property name=\"name\" value=\"小明\"/&gt; &lt;property name=\"address\" ref=\"addr\"/&gt; &lt;property name=\"books\"&gt; &lt;array&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 4、List注入 1234567&lt;property name=\"hobbys\"&gt; &lt;list&gt; &lt;value&gt;听歌&lt;/value&gt; &lt;value&gt;看电影&lt;/value&gt; &lt;value&gt;爬山&lt;/value&gt; &lt;/list&gt;&lt;/property&gt; 5、Map注入 123456&lt;property name=\"card\"&gt; &lt;map&gt; &lt;entry key=\"中国邮政\" value=\"456456456465456\"/&gt; &lt;entry key=\"建设\" value=\"1456682255511\"/&gt; &lt;/map&gt;&lt;/property&gt; 6、set注入 1234567&lt;property name=\"games\"&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;BOB&lt;/value&gt; &lt;value&gt;COC&lt;/value&gt; &lt;/set&gt;&lt;/property&gt; 7、Null注入 1&lt;property name&#x3D;&quot;wife&quot;&gt;&lt;null&#x2F;&gt;&lt;&#x2F;property&gt; 8、Properties注入 1234567&lt;property name&#x3D;&quot;info&quot;&gt; &lt;props&gt; &lt;prop key&#x3D;&quot;学号&quot;&gt;20190604&lt;&#x2F;prop&gt; &lt;prop key&#x3D;&quot;性别&quot;&gt;男&lt;&#x2F;prop&gt; &lt;prop key&#x3D;&quot;姓名&quot;&gt;小明&lt;&#x2F;prop&gt; &lt;&#x2F;props&gt;&lt;&#x2F;property&gt; 9、p命名和c命名注入 User.java ：【注意：这里没有有参构造器！】 1234567891011121314151617181920public class User &#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 1、P命名空间注入 : 需要在头文件中加入约束文件 1234导入约束 : xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.kuang.pojo.User&quot; p:name&#x3D;&quot;狂神&quot; p:age&#x3D;&quot;18&quot;&#x2F;&gt; 2、c 命名空间注入 : 需要在头文件中加入约束文件 123导入约束 : xmlns:c&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;c&quot;&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.kuang.pojo.User&quot; c:name&#x3D;&quot;狂神&quot; c:age&#x3D;&quot;18&quot;&#x2F;&gt; 发现问题：爆红了，刚才我们没有写有参构造！ 解决：把有参构造器加上，这里也能知道，c 就是所谓的构造器注入！ 测试代码： 123456@Testpublic void test02()&#123; ApplicationContext context = newClassPathXmlApplicationContext(\"applicationContext.xml\"); User user = (User) context.getBean(\"user\"); System.out.println(user);&#125; Bean的作用域在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 . 几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。 Singleton(单例模式，默认)当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置： 1&lt;bean id=\"ServiceImpl\" class=\"cn.csdn.service.ServiceImpl\" scope=\"singleton\"&gt; 测试： 1234567@Testpublic void test03()&#123; ApplicationContext context = newClassPathXmlApplicationContext(\"applicationContext.xml\"); User user = (User) context.getBean(\"user\"); User user2 = (User) context.getBean(\"user\"); System.out.println(user==user2);&#125; Prototype(原型模式)当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置： 123&lt;bean id=\"account\" class=\"com.foo.DefaultAccount\" scope=\"prototype\"/&gt; 或者&lt;bean id=\"account\" class=\"com.foo.DefaultAccount\" singleton=\"false\"/&gt; Request当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义： 1&lt;bean id=\"loginAction\" class=cn.csdn.LoginAction\" scope=\"request\"/&gt; 针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。 Session当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义： 1&lt;bean id=\"userPreferences\" class=\"com.foo.UserPreferences\" scope=\"session\"/&gt; 针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。 7.自动装配1. 自动装配说明 自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean。 Spring中bean有三种装配机制，分别是： 在xml中显式配置； 在java中显式配置； 隐式的bean发现机制和自动装配。 这里我们主要讲第三种：自动化的装配bean。 Spring的自动装配需要从两个角度来实现，或者说是两个操作： 组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean； 自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI； 组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。 推荐不使用自动装配xml配置 , 而使用注解 . 2. 测试环境搭建1、新建一个项目 2、新建两个实体类，Cat Dog 都有一个叫的方法 12345678910public class Cat &#123; public void shout() &#123; System.out.println(\"miao~\"); &#125;&#125;public class Dog &#123; public void shout() &#123; System.out.println(\"wang~\"); &#125;&#125; 3、新建一个用户类 User 12345public class User &#123; private Cat cat; private Dog dog; private String str;&#125; 4、编写Spring配置文件 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"dog\" class=\"com.kuang.pojo.Dog\"/&gt; &lt;bean id=\"cat\" class=\"com.kuang.pojo.Cat\"/&gt; &lt;bean id=\"user\" class=\"com.kuang.pojo.User\"&gt; &lt;property name=\"cat\" ref=\"cat\"/&gt; &lt;property name=\"dog\" ref=\"dog\"/&gt; &lt;property name=\"str\" value=\"qinjiang\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 5、测试 123456789public class MyTest &#123; @Test public void testMethodAutowire() &#123; ApplicationContext context &#x3D; newClassPathXmlApplicationContext(&quot;beans.xml&quot;); User user &#x3D; (User) context.getBean(&quot;user&quot;); user.getCat().shout(); user.getDog().shout(); &#125;&#125; 结果正常输出，环境OK 3. autowire byName (按名称自动装配)由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。 采用自动装配将避免这些错误，并且使配置简单化。 测试： 1、修改bean配置，增加一个属性 autowire=”byName” 123&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.kuang.pojo.User&quot; autowire&#x3D;&quot;byName&quot;&gt; &lt;property name&#x3D;&quot;str&quot; value&#x3D;&quot;qinjiang&quot;&#x2F;&gt;&lt;&#x2F;bean&gt; 2、再次测试，结果依旧成功输出！ 3、我们将 cat 的bean id修改为 catXXX 4、再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误。 小结： 当一个bean节点带有 autowire byName的属性时。 将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。 去spring容器中寻找是否有此字符串名称id的对象。 如果有，就取出注入；如果没有，就报空指针异常。 4. autowire byType (按类型自动装配)使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常。 1NoUniqueBeanDefinitionException 测试： 1、将user的bean配置修改一下 ： autowire=”byType” 2、测试，正常输出 3、在注册一个cat 的bean对象！ 1234567&lt;bean id=\"dog\" class=\"com.kuang.pojo.Dog\"/&gt;&lt;bean id=\"cat\" class=\"com.kuang.pojo.Cat\"/&gt;&lt;bean id=\"cat2\" class=\"com.kuang.pojo.Cat\"/&gt;&lt;bean id=\"user\" class=\"com.kuang.pojo.User\" autowire=\"byType\"&gt; &lt;property name=\"str\" value=\"qinjiang\"/&gt;&lt;/bean&gt; 4、测试，报错：NoUniqueBeanDefinitionException 5、删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。 这就是按照类型自动装配！ 使用注解 5. 使用注解jdk1.5开始支持注解，spring2.5开始全面支持注解。 准备工作：利用注解的方式注入属性。 在spring配置文件中引入context文件头，开启属性注解支持 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; @Autowired @Autowired是按类型自动转配的，不支持id匹配。 需要导入 spring-aop的包！ 测试： 1、将User类中的set方法去掉前提是自动装配的属性在IOC中存在且符合名字byname，使用@Autowired注解 12345678910111213141516171819public class User &#123; @Autowired private Cat cat; @Autowired private Dog dog; private String str; public Cat getCat() &#123; return cat; &#125; public Dog getDog() &#123; return dog; &#125; public String getStr() &#123; return str; &#125;&#125; 2、此时配置文件内容 12345&lt;context:annotation-config/&gt;&lt;bean id=\"dog\" class=\"com.kuang.pojo.Dog\"/&gt;&lt;bean id=\"cat\" class=\"com.kuang.pojo.Cat\"/&gt;&lt;bean id=\"user\" class=\"com.kuang.pojo.User\"/&gt; 3、测试，成功输出结果！ @Autowired(required=false) 说明：false，对象可以为null；true，对象必须存对象，不能为null。 123&#x2F;&#x2F;如果允许对象为null，设置required &#x3D; false,默认为true@Autowired(required &#x3D; false)private Cat cat; @Qualifier @Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配 @Qualifier不能单独使用。 测试实验步骤： 1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！ 1234&lt;bean id&#x3D;&quot;dog1&quot; class&#x3D;&quot;com.kuang.pojo.Dog&quot;&#x2F;&gt;&lt;bean id&#x3D;&quot;dog2&quot; class&#x3D;&quot;com.kuang.pojo.Dog&quot;&#x2F;&gt;&lt;bean id&#x3D;&quot;cat1&quot; class&#x3D;&quot;com.kuang.pojo.Cat&quot;&#x2F;&gt;&lt;bean id&#x3D;&quot;cat2&quot; class&#x3D;&quot;com.kuang.pojo.Cat&quot;&#x2F;&gt; 2、没有加Qualifier测试，直接报错 3、在属性上添加Qualifier注解 123456@Autowired@Qualifier(value &#x3D; &quot;cat2&quot;)private Cat cat;@Autowired@Qualifier(value &#x3D; &quot;dog2&quot;)private Dog dog; 测试，成功输出！ @Resource @Resource如有指定的name属性，先按该属性进行byName方式查找装配； 其次再进行默认的byName方式进行装配； 如果以上都不成功，则按byType的方式自动装配。 都不成功，则报异常。 实体类： 12345678public class User &#123; //如果允许对象为null，设置required = false,默认为true @Resource(name = \"cat2\") private Cat cat; @Resource private Dog dog; private String str;&#125; beans.xml 12345&lt;bean id=\"dog\" class=\"com.kuang.pojo.Dog\"/&gt;&lt;bean id=\"cat1\" class=\"com.kuang.pojo.Cat\"/&gt;&lt;bean id=\"cat2\" class=\"com.kuang.pojo.Cat\"/&gt;&lt;bean id=\"user\" class=\"com.kuang.pojo.User\"/&gt; 测试：结果OK 配置文件2：beans.xml ， 删掉cat2 12&lt;bean id&#x3D;&quot;dog&quot; class&#x3D;&quot;com.kuang.pojo.Dog&quot;&#x2F;&gt;&lt;bean id&#x3D;&quot;cat1&quot; class&#x3D;&quot;com.kuang.pojo.Cat&quot;&#x2F;&gt; 实体类上只保留注解 1234@Resourceprivate Cat cat;@Resourceprivate Dog dog; 结果：OK 结论：先进行byName查找，失败；再进行byType查找，成功。 小结@Autowired与@Resource异同： 1、@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。 2、@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，类型找不到按照名称进行装配，如果我们想使用名称装配可以结合@Qualifier注解进行使用 ==@Autowired：byType-&gt;byName== 3、@Resource（属于J2EE），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 ==@Resource：byName-&gt;byType，如果指定name，只byName== 它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。 8.使用注解开发使用注解开发 1. 说明在spring4之后，想要使用注解形式，必须得要引入aop的包 在配置文件当中，还得要引入一个context约束 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; 2. Bean的实现我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！ 1、配置扫描哪些包下的注解 12&lt;!--指定注解扫描包--&gt;&lt;context:component-scan base-package=\"com.kuang.pojo\"/&gt; 2、在指定包下编写类，增加注解 12345@Component(\"user\")// 相当于配置文件中 &lt;bean id=\"user\" class=\"当前注解的类\"/&gt;public class User &#123; public String name = \"秦疆\";&#125; 3、测试 1234567@Testpublic void test()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) applicationContext.getBean(\"user\"); System.out.println(user.name);&#125; 3. 属性注入使用注解注入属性 1、可以不用提供set方法，直接在直接名上添加@value(“值”) 1234567@Component(\"user\")// 相当于配置文件中 &lt;bean id=\"user\" class=\"当前注解的类\"/&gt;public class User &#123; @Value(\"秦疆\") // 相当于配置文件中 &lt;property name=\"name\" value=\"秦疆\"/&gt; public String name;&#125; 2、如果提供了set方法，在set方法上添加@value(“值”); 12345678910@Component(\"user\")public class User &#123; public String name; @Value(\"秦疆\") public void setName(String name) &#123; this.name = name; &#125;&#125; 4. 衍生注解我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！ @Component三个衍生注解 为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。 @Controller：web层 @Service：service层 @Repository：dao层 写上这些注解，就相当于将这个类交给Spring管理装配了！ 自动装配注解 在Bean的自动装配已经讲过了，可以回顾！ 作用域 @scope singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。 prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收 123456@Controller(\"user\")@Scope(\"prototype\")public class User &#123; @Value(\"秦疆\") public String name;&#125; 小结 XML与注解比较 XML可以适用任何场景 ，结构清晰，维护方便 注解不是自己提供的类使用不了，开发简单方便 xml与注解整合开发 ：推荐最佳实践 xml管理Bean 注解完成属性注入 使用过程中， 可以不用扫描，扫描是为了类上的注解 1&lt;context:annotation-config&#x2F;&gt; 作用： 进行注解驱动注册，从而使注解生效 用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册 如果不扫描包，就需要手动配置bean 如果不加注解驱动，则注入的值为null！ ​ 9.基于Java类进行配置JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。 测试： 1、编写一个实体类，Dog 1234@Component //将这个类标注为Spring的一个组件，放到容器中！public class Dog &#123; public String name = \"dog\";&#125; 2、新建一个config配置包，编写一个MyConfig配置类 123456789@Configuration //代表这是一个配置类public class MyConfig &#123; @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！ public Dog getdog()&#123; return new Dog(); &#125;&#125; 3、测试 1234567@Testpublic void test2()&#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MyConfig.class); Dog dog = (Dog) applicationContext.getBean(\"getDog\"); System.out.println(dog.name);&#125; 4、成功输出结果！ 导入其他配置如何做呢？ 1、我们再编写一个配置类！ 123@Configuration //代表这是一个配置类public class MyConfig2 &#123;&#125; 2、在之前的配置类中我们来选择导入这个配置类 12345678910@Configuration@Import(MyConfig2.class) //导入合并其他配置类，类似于配置文件中的 inculde 标签public class MyConfig &#123; @Bean public Dog dog()&#123; return new Dog(); &#125;&#125; 关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！ 10.代理模式为什么要学习代理模式，因为AOP的底层机制就是动态代理！ 代理模式： 静态代理 动态代理 学习aop之前 , 我们要先了解一下代理模式！ 1. 静态代理静态代理角色分析 抽象角色 : 一般使用接口或者抽象类来实现 真实角色 : 被代理的角色 代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 . 客户 : 使用代理角色来进行一些操作 . ​ 代码实现 Rent . java 即抽象角色 1234//抽象角色：租房public interface Rent &#123; public void rent();&#125; Host . java 即真实角色 123456//真实角色: 房东，房东要出租房子public class Host implements Rent&#123; public void rent() &#123; System.out.println(\"房屋出租\"); &#125;&#125; Proxy . java 即代理角色 123456789101112131415161718192021222324//代理角色：中介public class Proxy implements Rent &#123; private Host host; public Proxy() &#123; &#125; public Proxy(Host host) &#123; this.host = host; &#125; //租房 public void rent()&#123; seeHouse(); host.rent(); fare(); &#125; //看房 public void seeHouse()&#123; System.out.println(\"带房客看房\"); &#125; //收中介费 public void fare()&#123; System.out.println(\"收中介费\"); &#125;&#125; Client . java 即客户 123456789101112//客户类，一般客户都会去找代理！public class Client &#123; public static void main(String[] args) &#123; //房东要租房 Host host = new Host(); //中介帮助房东 Proxy proxy = new Proxy(host); //你去找中介！ proxy.rent(); &#125;&#125; 分析：在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。 静态代理的好处: 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 缺点 : 一个真实角色就会产生一个代理角色，工作量变大了，开发效率降低。 我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 ! 2. 静态代理再理解练习步骤： 1、创建一个抽象角色，比如咋们平时做的用户业务，抽象起来就是增删改查！ 1234567//抽象角色：增删改查业务public interface UserService &#123; void add(); void delete(); void update(); void query();&#125; 2、我们需要一个真实对象来完成这些增删改查操作 12345678910111213141516171819//真实对象，完成增删改查操作的人public class UserServiceImpl implements UserService &#123; public void add() &#123; System.out.println(\"增加了一个用户\"); &#125; public void delete() &#123; System.out.println(\"删除了一个用户\"); &#125; public void update() &#123; System.out.println(\"更新了一个用户\"); &#125; public void query() &#123; System.out.println(\"查询了一个用户\"); &#125;&#125; 3、需求来了，现在我们需要增加一个日志功能，怎么实现！ 思路1 ：在实现类上增加代码 【麻烦！】 思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！ 4、设置一个代理类来处理日志！代理角色 123456789101112131415161718192021222324252627282930313233//代理角色，在这里面增加日志的实现public class UserServiceProxy implements UserService &#123; private UserServiceImpl userService; public void setUserService(UserServiceImpl userService) &#123; this.userService = userService; &#125; public void add() &#123; log(\"add\"); userService.add(); &#125; public void delete() &#123; log(\"delete\"); userService.delete(); &#125; public void update() &#123; log(\"update\"); userService.update(); &#125; public void query() &#123; log(\"query\"); userService.query(); &#125; public void log(String msg)&#123; System.out.println(\"执行了\"+msg+\"方法\"); &#125;&#125; 5、测试访问类： 123456789101112public class Client &#123; public static void main(String[] args) &#123; //真实业务 UserServiceImpl userService = new UserServiceImpl(); //代理类 UserServiceProxy proxy = new UserServiceProxy(); //使用代理类实现日志功能！ proxy.setUserService(userService); proxy.add(); &#125;&#125; 我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想 聊聊AOP：纵向开发，横向开发 3. 动态代理 动态代理的角色和静态代理的一样 . 动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的 动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理 基于接口的动态代理—-JDK动态代理- 基于类的动态代理--cglib - 现在用的比较多的是 javasist 来生成动态代理 . 百度一下javassist - 我们这里使用JDK的原生代码来实现，其余的道理都是一样的！、 JDK的动态代理需要了解两个类 核心 : InvocationHandler 和 Proxy ， 打开JDK帮助文档看看 【InvocationHandler：调用处理程序】 12345Object invoke(Object proxy, 方法 method, Object[] args)；&#x2F;&#x2F;参数&#x2F;&#x2F;proxy - 调用该方法的代理实例&#x2F;&#x2F;method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。&#x2F;&#x2F;args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。 【Proxy : 代理】 12345//生成代理类public Object getProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this);&#125; 代码实现 抽象角色和真实角色和之前的一样！ Rent . java 即抽象角色 1234//抽象角色：租房public interface Rent &#123; public void rent();&#125; Host . java 即真实角色 123456//真实角色: 房东，房东要出租房子public class Host implements Rent&#123; public void rent() &#123; System.out.println(\"房屋出租\"); &#125;&#125; ProxyInvocationHandler. java 即代理角色 12345678910111213141516171819202122232425262728293031323334public class ProxyInvocationHandler implements InvocationHandler &#123; private Rent rent; public void setRent(Rent rent) &#123; this.rent = rent; &#125; //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色 public Object getProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this); &#125; // proxy : 代理类 method : 代理类的调用处理程序的方法对象. // 处理代理实例上的方法调用并返回结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throwsThrowable &#123; seeHouse(); //核心：本质利用反射实现！ Object result = method.invoke(rent, args); fare(); return result; &#125; //看房 public void seeHouse()&#123; System.out.println(\"带房客看房\"); &#125; //收中介费 public void fare()&#123; System.out.println(\"收中介费\"); &#125;&#125; Client . java 1234567891011121314//租客public class Client &#123; public static void main(String[] args) &#123; //真实角色 Host host = new Host(); //代理实例的调用处理程序 ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setRent(host); //将真实角色放置进去！ Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！ proxy.rent(); &#125;&#125; 核心：一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！、 4. 深化理解我们来使用动态代理实现代理我们后面写的UserService！ 我们也可以编写一个通用的动态代理实现的类！所有的代理对象设置为Object即可！ 1234567891011121314151617181920212223242526public class ProxyInvocationHandler implements InvocationHandler &#123; private Object target; public void setTarget(Object target) &#123; this.target &#x3D; target; &#125; &#x2F;&#x2F;生成代理类 public Object getProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this); &#125; &#x2F;&#x2F; proxy : 代理类 &#x2F;&#x2F; method : 代理类的调用处理程序的方法对象. public Object invoke(Object proxy, Method method, Object[] args) throwsThrowable &#123; log(method.getName()); Object result &#x3D; method.invoke(target, args); return result; &#125; public void log(String methodName)&#123; System.out.println(&quot;执行了&quot;+methodName+&quot;方法&quot;); &#125;&#125; 测试！ 1234567891011public class Test &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;真实对象 UserServiceImpl userService &#x3D; new UserServiceImpl(); &#x2F;&#x2F;代理对象的调用处理程序 ProxyInvocationHandler pih &#x3D; new ProxyInvocationHandler(); pih.setTarget(userService); &#x2F;&#x2F;设置要代理的对象 UserService proxy &#x3D; (UserService)pih.getProxy(); &#x2F;&#x2F;动态生成代理类！ proxy.delete(); &#125;&#125; 测试，增删改查，查看结果！ 动态代理的好处 静态代理有的它都有，静态代理没有的，它也有！ 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 一个动态代理 , 一般代理某一类业务 一个动态代理可以代理多个类，代理的是接口！ 11.AOP1. 什么是AOPAOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 2. Aop在Spring中的作用提供声明式事务；允许用户自定义切面 以下名词需要了解下： 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 …. 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 目标（Target）：被通知对象。 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（PointCut）：切面通知 执行的 “地点”的定义。 连接点（JointPoint）：与切入点匹配的执行点。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice: 即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 . 3. 使用Spring实现Aop【重点】使用AOP织入，需要导入一个依赖包！ 123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 1.第一种方式, 通过 Spring API 实现首先编写我们的业务接口和实现类 1234567891011public interface UserService &#123; public void add(); public void delete(); public void update(); public void search();&#125; 12345678910111213141516171819202122public class UserServiceImpl implements UserService&#123; @Override public void add() &#123; System.out.println(\"增加用户\"); &#125; @Override public void delete() &#123; System.out.println(\"删除用户\"); &#125; @Override public void update() &#123; System.out.println(\"更新用户\"); &#125; @Override public void search() &#123; System.out.println(\"查询用户\"); &#125;&#125; 然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强 12345678910111213141516171819202122public class Log implements MethodBeforeAdvice &#123; //method : 要执行的目标对象的方法 //objects : 被调用的方法的参数 //Object : 目标对象 @Override public void before(Method method, Object[] objects, Object o) throws Throwable &#123; System.out.println( o.getClass().getName() + \"的\" + method.getName() + \"方法被执行了\"); &#125;&#125;public class AfterLog implements AfterReturningAdvice &#123; //returnValue 返回值 //method被调用的方法 //args 被调用的方法的对象的参数 //target 被调用的目标对象 @Override public void afterReturning(Object returnValue, Method method, Object[] args,Object target) throws Throwable &#123; System.out.println(\"执行了\" + target.getClass().getName() +\"的\"+method.getName()+\"方法,\" +\"返回值：\"+returnValue); &#125;&#125; 最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 . 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--注册bean--&gt; &lt;bean id=\"userService\" class=\"com.kuang.service.UserServiceImpl\"/&gt; &lt;bean id=\"log\" class=\"com.kuang.log.Log\"/&gt; &lt;bean id=\"afterLog\" class=\"com.kuang.log.AfterLog\"/&gt; &lt;!--aop的配置--&gt; &lt;aop:config&gt; &lt;!--切入点 expression:表达式匹配要执行的方法--&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.kuang.service.UserServiceImpl.*(..))\"/&gt; &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt; &lt;aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/&gt; &lt;aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试 12345678public class MyTest &#123; @Test public void test()&#123; ApplicationContext context = newClassPathXmlApplicationContext(\"beans.xml\"); UserService userService = (UserService) context.getBean(\"userService\"); userService.search(); &#125;&#125; Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 . Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 . 2.第二种方式,自定义类来实现Aop目标业务类不变依旧是userServiceImpl 第一步 : 写我们自己的一个切入类 12345678910public class DiyPointcut &#123; public void before()&#123; System.out.println(\"---------方法执行前---------\"); &#125; public void after()&#123; System.out.println(\"---------方法执行后---------\"); &#125; &#125; 去spring中配置 12345678910111213&lt;!--第二种方式自定义实现--&gt;&lt;!--注册bean--&gt;&lt;bean id=\"diy\" class=\"com.kuang.config.DiyPointcut\"/&gt;&lt;!--aop的配置--&gt;&lt;aop:config&gt; &lt;!--第二种方式：使用AOP的标签实现--&gt; &lt;aop:aspect ref=\"diy\"&gt; &lt;aop:pointcut id=\"diyPonitcut\" expression=\"execution(* com.kuang.service.UserServiceImpl.*(..))\"/&gt; &lt;aop:before pointcut-ref=\"diyPonitcut\" method=\"before\"/&gt; &lt;aop:after pointcut-ref=\"diyPonitcut\" method=\"after\"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 测试： 12345678public class MyTest &#123; @Test public void test()&#123; ApplicationContext context = newClassPathXmlApplicationContext(\"beans.xml\"); UserService userService = (UserService) context.getBean(\"userService\"); userService.add(); &#125;&#125; 3.第三种方式,使用注解实现第一步：编写一个注解实现的增强类 123456789101112131415161718192021222324252627282930package com.kuang.config;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class AnnotationPointcut &#123; @Before(\"execution(* com.kuang.service.UserServiceImpl.*(..))\") public void before()&#123; System.out.println(\"---------方法执行前---------\"); &#125; @After(\"execution(* com.kuang.service.UserServiceImpl.*(..))\") public void after()&#123; System.out.println(\"---------方法执行后---------\"); &#125; @Around(\"execution(* com.kuang.service.UserServiceImpl.*(..))\") public void around(ProceedingJoinPoint jp) throws Throwable &#123; System.out.println(\"环绕前\"); System.out.println(\"签名:\"+jp.getSignature()); //执行目标方法proceed Object proceed = jp.proceed(); System.out.println(\"环绕后\"); System.out.println(proceed); &#125;&#125; 第二步：在Spring配置文件中，注册bean，并增加支持注解的配置 123&lt;!--第三种方式:注解实现--&gt;&lt;bean id=\"annotationPointcut\" class=\"com.kuang.config.AnnotationPointcut\"/&gt;&lt;aop:aspectj-autoproxy/&gt; aop:aspectj-autoproxy：说明 123通过aop命名空间的&lt;aop:aspectj-autoproxy &#x2F;&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy &#x2F;&gt;隐藏起来了&lt;aop:aspectj-autoproxy &#x2F;&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy poxy-target-class&#x3D;&quot;true&quot;&#x2F;&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。 12.整合MyBatis1.步骤1、导入相关jar包 junit 12345&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; mybatis 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt; mysql-connector-java 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt; spring相关 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;&lt;/dependency&gt; aspectJ AOP 织入器 123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; mybatis-spring整合包 【重点】 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 配置Maven静态资源过滤问题！ 123456789101112&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 2、编写配置文件 3、代码实现 2.回忆MyBatis编写pojo实体类 1234567package com.kuang.pojo;public class User &#123; private int id; //id private String name; //姓名 private String pwd; //密码&#125; 实现mybatis的配置文件 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=\"com.kuang.pojo\"/&gt; &lt;/typeAliases&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;package name=\"com.kuang.dao\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; UserDao接口编写 123public interface UserMapper &#123; public List&lt;User&gt; selectUser();&#125; 接口对应的Mapper映射文件 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.kuang.dao.UserMapper\"&gt; &lt;select id=\"selectUser\" resultType=\"User\"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 测试类 1234567891011121314151617@Testpublic void selectUser() throws IOException &#123; String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = newSqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.selectUser(); for (User user: userList)&#123; System.out.println(user); &#125; sqlSession.close();&#125; 3.MyBatis-Spring学习引入Spring之前需要了解mybatis-spring包中的一些重要类； http://www.mybatis.org/spring/zh/index.html 什么是 MyBatis-Spring？ MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。 知识基础 在开始使用 MyBatis-Spring 之前，你需要先熟悉 Spring 和 MyBatis 这两个框架和有关它们的术语。这很重要 MyBatis-Spring 需要以下版本： MyBatis-Spring MyBatis Spring 框架 Spring Batch Java 2.0 3.5+ 5.0+ 4.0+ Java 8+ 1.3 3.4+ 3.2.2+ 2.1+ Java 6+ 如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可： 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 SqlSessionFactory 和至少一个数据映射器类。 在 MyBatis-Spring 中，可使用SqlSessionFactoryBean来创建 SqlSessionFactory。要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中： 123&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt; 注意：SqlSessionFactory需要一个 DataSource（数据源）。这可以是任意的 DataSource，只需要和配置其它 Spring 数据库连接一样配置它就可以了。 在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的。而在 MyBatis-Spring 中，则使用 SqlSessionFactoryBean 来创建。 在 MyBatis 中，你可以使用 SqlSessionFactory 来创建 SqlSession。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。 SqlSessionFactory有一个唯一的必要属性：用于 JDBC 的 DataSource。这可以是任意的 DataSource 对象，它的配置方法和其它 Spring 数据库连接是一样的。 一个常用的属性是 configLocation，它用来指定 MyBatis 的 XML 配置文件路径。它在需要修改 MyBatis 的基础配置非常有用。通常，基础配置指的是 &lt; settings&gt; 或 &lt; typeAliases&gt;元素。 需要注意的是，这个配置文件并不需要是一个完整的 MyBatis 配置。确切地说，任何环境配置（），数据源（）和 MyBatis 的事务管理器（）都会被忽略。SqlSessionFactoryBean 会创建它自有的 MyBatis 环境配置（Environment），并按要求设置自定义环境的值。 SqlSessionTemplate 是 MyBatis-Spring 的核心。作为 SqlSession 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 SqlSession。 模板可以参与到 Spring 的事务管理中，并且由于其是线程安全的，可以供多个映射器类使用，你应该总是用 SqlSessionTemplate 来替换 MyBatis 默认的 DefaultSqlSession 实现。在同一应用程序中的不同类之间混杂使用可能会引起数据一致性的问题。 可以使用 SqlSessionFactory 作为构造方法的参数来创建 SqlSessionTemplate 对象。 123&lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\" /&gt;&lt;/bean&gt; 现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样： 123456789101112public class UserDaoImpl implements UserDao &#123; private SqlSession sqlSession; public void setSqlSession(SqlSession sqlSession) &#123; this.sqlSession = sqlSession; &#125; public User getUser(String userId) &#123; return sqlSession.getMapper...; &#125;&#125; 按下面这样，注入 SqlSessionTemplate： 123&lt;bean id=\"userDao\" class=\"org.mybatis.spring.sample.dao.UserDaoImpl\"&gt; &lt;property name=\"sqlSession\" ref=\"sqlSession\" /&gt;&lt;/bean&gt; 4.整合实现一1、引入Spring配置文件beans.xml 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的--&gt; &lt;bean id=\"dataSource\"class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/bean&gt; &lt;!--配置SqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!--关联Mybatis--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/kuang/dao/*.xml\"/&gt; &lt;/bean&gt; &lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt; &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;!--利用构造器注入--&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 2、配置数据源替换mybaits的数据源 3、配置SqlSessionFactory，关联MyBatis 4、注册sqlSessionTemplate，关联sqlSessionFactory； 5、增加Dao接口的实现类；私有化sqlSessionTemplate 123456789101112131415public class UserDaoImpl implements UserMapper &#123; //sqlSession不用我们自己创建了，Spring来管理 private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) &#123; this.sqlSession = sqlSession; &#125; public List&lt;User&gt; selectUser() &#123; UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); &#125; &#125; 6、注册bean实现 123&lt;bean id=\"userDao\" class=\"com.kuang.dao.UserDaoImpl\"&gt; &lt;property name=\"sqlSession\" ref=\"sqlSession\"/&gt;&lt;/bean&gt; 7、测试 1234567@Testpublic void test2()&#123; ApplicationContext context = newClassPathXmlApplicationContext(\"beans.xml\"); UserMapper mapper = (UserMapper) context.getBean(\"userDao\"); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user);&#125; 结果成功输出！现在我们的Mybatis配置文件的状态！发现都可以被Spring整合！ 123456789&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name&#x3D;&quot;com.kuang.pojo&quot;&#x2F;&gt; &lt;&#x2F;typeAliases&gt;&lt;&#x2F;configuration&gt; 5.整合实现二mybatis-spring1.2.3版以上的才有这个 . dao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式1 , 不需要管理SqlSessionTemplate , 而且对事务的支持更加友好 . 可跟踪源码查看 测试： 1、将我们上面写的UserDaoImpl修改一下 123456public class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper &#123; public List&lt;User&gt; selectUser() &#123; UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.selectUser(); &#125;&#125; 2、修改bean的配置 123&lt;bean id=\"userDao\" class=\"com.kuang.dao.UserDaoImpl\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\" /&gt;&lt;/bean&gt; 3、测试 1234567@Testpublic void test2()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); UserMapper mapper = (UserMapper) context.getBean(\"userDao\"); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user);&#125; 总结 : 整合到spring以后可以完全不要mybatis的配置文件，除了这些方式可以实现整合之外，我们还可以使用注解来实现，这个等我们后面学习SpringBoot的时候还会测试整合！ 13.事务1. 回顾事务 事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！ 事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。 事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。 事务四个属性ACID 原子性（atomicity） 事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用 一致性（consistency） 一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中 隔离性（isolation） 可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏 持久性（durability） 事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中 测试 将上面的代码拷贝到一个新项目中 在之前的案例中，我们给userDao接口新增两个方法，删除和增加用户； 12345&#x2F;&#x2F;添加一个用户int addUser(User user);&#x2F;&#x2F;根据id删除用户int deleteUser(int id); mapper文件，我们故意把 deletes 写错，测试！ 1234567&lt;insert id&#x3D;&quot;addUser&quot; parameterType&#x3D;&quot;com.kuang.pojo.User&quot;&gt;insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&lt;&#x2F;insert&gt;&lt;delete id&#x3D;&quot;deleteUser&quot; parameterType&#x3D;&quot;int&quot;&gt;deletes from user where id &#x3D; #&#123;id&#125;&lt;&#x2F;delete&gt; 编写接口的实现类，在实现类中，我们去操作一波 1234567891011121314151617181920212223public class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper &#123; //增加一些操作 public List&lt;User&gt; selectUser() &#123; User user = new User(4,\"小明\",\"123456\"); UserMapper mapper = getSqlSession().getMapper(UserMapper.class); mapper.addUser(user); mapper.deleteUser(4); return mapper.selectUser(); &#125; //新增 public int addUser(User user) &#123; UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.addUser(user); &#125; //删除 public int deleteUser(int id) &#123; UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.deleteUser(id); &#125;&#125; 测试 1234567@Testpublic void test2()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); UserMapper mapper = (UserMapper) context.getBean(\"userDao\"); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user);&#125; 报错：sql异常，delete写错了 结果 ：插入成功！ 没有进行事务的管理；我们想让他们都成功才成功，有一个失败，就都失败，我们就应该需要事务！ 以前我们都需要自己手动管理事务，十分麻烦！ 但是Spring给我们提供了事务管理，我们只需要配置即可； 2. Spring中的事务管理Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。 编程式事务管理 将事务管理代码嵌到业务方法中来控制事务的提交和回滚 缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码 声明式事务管理 一般情况下比编程式事务好用。 将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。 将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理。 使用Spring管理事务，注意头文件的约束导入 : tx 1234xmlns:tx=\"http://www.springframework.org/schema/tx\"http://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; 事务管理器 无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。 就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。 JDBC事务 123&lt;bean id=\"transactionManager\"class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt; 配置好事务管理器后我们需要去配置事务的通知 123456789101112&lt;!--配置事务通知--&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt; &lt;tx:method name=\"add\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"update\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"search*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"get\" read-only=\"true\"/&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; spring事务传播特性： 事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为： propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。 propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。 propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。 propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作 Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。 假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。 就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！ 配置AOP 导入aop的头文件！ 12345&lt;!--配置aop织入事务--&gt;&lt;aop:config&gt; &lt;aop:pointcut id=\"txPointcut\" expression=\"execution(* com.kuang.dao.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointcut\"/&gt;&lt;/aop:config&gt; 进行测试 删掉刚才插入的数据，再次测试！ 1234567@Testpublic void test2()&#123; ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserMapper mapper &#x3D; (UserMapper) context.getBean(&quot;userDao&quot;); List&lt;User&gt; user &#x3D; mapper.selectUser(); System.out.println(user);&#125; 思考问题？ 为什么需要配置事务？ 如果不配置，就需要我们手动提交控制事务； 事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！ ​","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-06-18T09:11:46.529Z","updated":"2020-06-18T11:27:15.893Z","comments":true,"path":"2020/06/18/hello-world/","link":"","permalink":"http://yoursite.com/2020/06/18/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"备忘","slug":"备忘","permalink":"http://yoursite.com/categories/%E5%A4%87%E5%BF%98/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://yoursite.com/tags/TCP-IP/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"},{"name":"科学上网","slug":"科学上网","permalink":"http://yoursite.com/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]}